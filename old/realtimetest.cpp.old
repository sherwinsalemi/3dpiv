#include <libuvc/libuvc.h>
#include <stdio.h>
#include <unistd.h>

#include <opencv2/core.hpp>
#include <opencv2/imgcodecs.hpp>
#include <opencv2/highgui.hpp>

#include <stdint.h>

bool streaming = true;

uint32_t frameCounter = 0;

void cb(uvc_frame_t *frame, void *ptr)
{
    //printf("Callback\n");
    uvc_frame_t* bgr;
    uvc_error_t ret;
    enum uvc_frame_format* frame_format = (enum uvc_frame_format*)ptr;
    /* FILE *fp;
    * static int jpeg_count = 0;
    * static const char *H264_FILE = "iOSDevLog.h264";
    * static const char *MJPEG_FILE = ".jpeg";
    * char filename[16]; */

    /* We'll convert the image from YUV/JPEG to BGR, so allocate space */
    bgr = uvc_allocate_frame(frame->width * frame->height * 3);
    if (!bgr) {
        printf("unable to allocate bgr frame!\n");
        return;
    }

    //printf("callback! frame_format = %d, width = %d, height = %d, length = %lu, ptr = %p\n",
  

    switch (frame->frame_format) {
    //   case UVC_FRAME_FORMAT_H264:
    //     /* use `ffplay H264_FILE` to play */
    //     /* fp = fopen(H264_FILE, "a");
    //      * fwrite(frame->data, 1, frame->data_bytes, fp);
    //      * fclose(fp); */
    //     break;
    case UVC_COLOR_FORMAT_MJPEG:
    /* sprintf(filename, "%d%s", jpeg_count++, MJPEG_FILE);
        * fp = fopen(filename, "w");
        * fwrite(frame->data, 1, frame->data_bytes, fp);
        * fclose(fp); */
    break;
    case UVC_COLOR_FORMAT_YUYV:
    /* Do the BGR conversion */
        printf("Convert success\n");
        ret = uvc_any2bgr(frame, bgr);
        if (ret) {
            uvc_perror(ret, "uvc_any2bgr");
            uvc_free_frame(bgr);
            return;
        }
        break;
        default:
        break;
    }

    // for (int y = 0; y < bgr->width; y += 50)
    // {
    //     for (int x = 0; x < bgr->width; x += 50)
    //     {
    //         printf("%u", ((uint8_t*)bgr->data)[3*x+3*bgr->width*y]);
    //     }
    //     printf("\n");
    // }

    // for (int i = 0; i < 100; i++)
    // {
    //     printf("%u", ((uint8_t*)bgr->data)[i]);
    // }

    printf ("W: %lu, H: %lu, Bytes: %llu", bgr->width, bgr->height, bgr->data_bytes);

    cv::Mat cvFrame(frame->height, frame->width, CV_8UC3, frame->data_bytes);

    if (cvFrame.empty())
    {
        printf("Emptyiu\n");
    }
    else
    {
        cv::imshow("Big brain", cvFrame);
    }
    

    printf("\n\n\n");

    uvc_free_frame(bgr);
}

int main()
{
    printf("Test\n");

    uvc_error_t res;

    uvc_context_t* ctx;
    res = uvc_init(&ctx, NULL);
    if (res < 0)
    {
        printf("Failed to init LibUVC\n");
        uvc_perror(res, "uvc_init");
        return res;
    }
    printf("UVC Initialized\n");

    uvc_device_t* dev;
    res = uvc_find_device(ctx, &dev, 0, 0, NULL);
    if (res < 0)
    {
        printf("Failed to find device\n");
        uvc_perror(res, "uvc_find_device");
        return res;
    }

    printf("Device found\n");
    uvc_device_handle_t *devh;
    res = uvc_open(dev, &devh);
    if (res < 0)
    {
        printf("Failed open stream with device, in use?\n");
        uvc_perror(res, "uvc_open");
        return res;
    }

    uvc_print_diag(devh, stderr);
    const uvc_format_desc_t* format_desc = uvc_get_format_descs(devh);
    const uvc_frame_desc_t* frame_desc = format_desc->frame_descs;
    enum uvc_frame_format frame_format;
    int width = 640;
    int height = 480;
    int fps = 30;
    switch (format_desc->bDescriptorSubtype)
    {
    case UVC_VS_FORMAT_MJPEG:
        frame_format = UVC_COLOR_FORMAT_MJPEG;
        break;
    case UVC_VS_FORMAT_FRAME_BASED:
        printf("Unsupported Format_Frame_Based\n");
        return 1;
        // frame_format = UVC_FRAME_FORMAT_H264;
        break;
    default:
        frame_format = UVC_FRAME_FORMAT_YUYV;
        break;
    }

    if (frame_desc) {
        width = frame_desc->wWidth;
        height = frame_desc->wHeight;
        fps = 10000000 / frame_desc->dwDefaultFrameInterval;
    }
    printf("\nFirst format: (%4s) %dx%d %dfps\n", format_desc->fourccFormat, width, height, fps);
    uvc_stream_ctrl_t ctrl;
    /* Try to negotiate first stream profile */
    res = uvc_get_stream_ctrl_format_size(
        devh, &ctrl, /* result stored in ctrl */
        frame_format,
        width, height, fps /* width, height, fps */
    );

    /* Print out the result */
    uvc_print_stream_ctrl(&ctrl, stderr);

    if (res < 0) {
        uvc_perror(res, "get_mode"); /* device doesn't provide a matching stream */
        return 1;
    } 
    /* Start the video stream. The library will call user function cb:
        *   cb(frame, (void *) 12345)
        */
    res = uvc_start_streaming(devh, &ctrl, cb, (void *) 12345, 0);

    if (res < 0) {
        uvc_perror(res, "start_streaming"); /* unable to start stream */
        printf("Unable to start stream\n");
        return 1;
    } else {
        printf("Streaming...\n");

        const uint8_t UVC_AUTO_EXPOSURE_MODE_AUTO = 2;
        res = uvc_set_ae_mode(devh, UVC_AUTO_EXPOSURE_MODE_AUTO);

        if (res == UVC_SUCCESS) {
            printf("enabled auto exposure\n");
        } else if (res == UVC_ERROR_PIPE) {
            /* this error indicates that the camera does not support the full AE mode;
                * try again, using aperture priority mode (fixed aperture, variable exposure time) */

            printf("full AE not supported, trying aperture priority mode\n");
            const uint8_t UVC_AUTO_EXPOSURE_MODE_APERTURE_PRIORITY = 8;
            res = uvc_set_ae_mode(devh, UVC_AUTO_EXPOSURE_MODE_APERTURE_PRIORITY);

            if (res < 0) {
                uvc_perror(res, "uvc_set_ae_mode failed to enable aperture priority mode");
            } else {
                printf("enabled aperture priority auto exposure mode\n");
            }
        } else {
            uvc_perror(res, "uvc_set_ae_mode failed to enable auto exposure mode");
        }

        while (streaming)
        {
        }

        uvc_stop_streaming(devh);
        printf("Done streaming.\n");
    }

    /* Release our handle on the device */
    uvc_close(devh);
    printf("Device closed\n");
    

    /* Release the device descriptor */
    uvc_unref_device(dev);
    

    /* Close the UVC context. This closes and cleans up any existing device handles,
    * and it closes the libusb context if one was not provided. */
    uvc_exit(ctx);
    printf("UVC exited\n");

    return 0;

}